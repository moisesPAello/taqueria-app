const express = require('express');
const router = express.Router();
const db = require('../../../config/database');

// Función helper para formatear fecha a zona horaria de Hermosillo
const formatearFechaHermosillo = (fecha) => {
    return strftime('%Y-%m-%dT%H:%M:%S.000Z', datetime(fecha, '-7 hours'));
};

// Obtener órdenes activas
router.get('/', (req, res) => {
    const query = `
        SELECT 
            o.id,
            o.total,
            o.estado,
            strftime('%Y-%m-%dT%H:%M:%S.000Z', datetime(o.fecha_creacion, '-7 hours')) as fecha_creacion,
            json_object('numero', m.numero) as mesa,
            u.nombre as mesero_nombre,
            COUNT(d.id) as productos
        FROM ordenes o
        LEFT JOIN mesas m ON o.mesa_id = m.id
        LEFT JOIN usuarios u ON o.usuario_id = u.id
        LEFT JOIN detalles_orden d ON o.id = d.orden_id
        WHERE o.estado = 'activa'
        GROUP BY o.id
    `;

    db.all(query, [], (err, rows) => {
        if (err) {
            console.error('Error en la consulta:', err);
            res.status(500).json({ error: err.message });
            return;
        }

        const formattedRows = rows.map(row => ({
            ...row,
            fecha_creacion: row.fecha_creacion,
            total: parseFloat(row.total).toFixed(2),
            mesa: JSON.parse(row.mesa)
        }));

        res.json(formattedRows);
    });
});

// Añadir ruta para obtener detalles de una orden específica
router.get('/:id', (req, res) => {
    const { id } = req.params;
    
    const query = `
        SELECT 
            strftime('%Y-%m-%dT%H:%M:%S.000Z', datetime(o.fecha_creacion, '-7 hours')) as fecha_creacion,
            o.id,
            o.estado,
            o.total,
            o.num_personas,
            o.notas,
            m.numero as mesa_numero,
            u.nombre as mesero_nombre,
            json_group_array(
                json_object(
                    'id', p.id,
                    'nombre', p.nombre,
                    'precio', d.precio_unitario,
                    'cantidad', d.cantidad,
                    'notas', COALESCE(d.notas, '')
                )
            ) as productos
        FROM ordenes o
        JOIN mesas m ON o.mesa_id = m.id
        LEFT JOIN usuarios u ON o.usuario_id = u.id
        LEFT JOIN detalles_orden d ON o.id = d.orden_id
        LEFT JOIN productos p ON d.producto_id = p.id
        WHERE o.id = ?
        GROUP BY o.id, m.numero, u.nombre
    `;

    db.get(query, [id], (err, orden) => {
        if (err) {
            console.error('Error al obtener orden:', err);
            res.status(500).json({ error: err.message });
            return;
        }

        if (!orden) {
            res.status(404).json({ error: 'Orden no encontrada' });
            return;
        }

        try {
            orden.productos = JSON.parse(orden.productos);
            if (orden.productos[0].id === null) {
                orden.productos = [];
            }
            res.json(orden);
        } catch (parseErr) {
            console.error('Error al parsear productos:', parseErr);
            res.status(500).json({ error: 'Error al procesar los datos de la orden' });
        }
    });
});

// Crear nueva orden
router.post('/', (req, res) => {
    const { mesa_id, mesero_id, productos, num_personas, notas } = req.body;
    const usuario_id = req.user?.id;

    if (!usuario_id) {
        return res.status(401).json({ error: 'Usuario no autenticado' });
    }
    
    if (!mesa_id || !mesero_id || !productos || !Array.isArray(productos) || productos.length === 0) {
        return res.status(400).json({ error: 'Datos de orden incompletos o inválidos' });
    }

    db.serialize(() => {
        db.run('BEGIN TRANSACTION');
        
        try {
            // 1. Verificar stock disponible
            const placeholders = productos.map(() => '?').join(',');
            const productIds = productos.map(p => p.producto_id);
            
            db.all(
                `SELECT id, precio, stock, nombre FROM productos WHERE id IN (${placeholders})`,
                productIds,
                function(err, productosInfo) {
                    if (err) {
                        console.error('Error al obtener productos:', err);
                        db.run('ROLLBACK');
                        return res.status(500).json({ error: 'Error al procesar la orden' });
                    }

                    const productosMap = new Map(productosInfo.map(p => [p.id, p]));
                    
                    // Verificar stock suficiente
                    const stockInsuficiente = productos.find(prod => {
                        const producto = productosMap.get(prod.producto_id);
                        return !producto || producto.stock < prod.cantidad;
                    });

                    if (stockInsuficiente) {
                        const producto = productosMap.get(stockInsuficiente.producto_id);
                        db.run('ROLLBACK');
                        return res.status(400).json({ 
                            error: `Stock insuficiente para ${producto.nombre}. Disponible: ${producto.stock}` 
                        });
                    }

                    // Calcular el total
                    const total = productos.reduce((sum, prod) => {
                        const precio = productosMap.get(prod.producto_id)?.precio || 0;
                        return sum + (precio * prod.cantidad);
                    }, 0);

                    // 2. Crear la orden
                    db.run(
                        `INSERT INTO ordenes (
                            mesa_id, 
                            usuario_id, 
                            estado, 
                            total,
                            num_personas, 
                            notas,
                            creado_por,
                            fecha_creacion
                        ) VALUES (?, ?, "activa", ?, ?, ?, ?, CURRENT_TIMESTAMP)`,
                        [mesa_id, mesero_id, total, num_personas || 1, notas || '', usuario_id],
                        function(err) {
                            if (err) {
                                console.error('Error al crear orden:', err);
                                db.run('ROLLBACK');
                                return res.status(500).json({ error: 'Error al crear la orden' });
                            }
                            
                            const orden_id = this.lastID;
                            
                            // 3. Insertar detalles y reducir stock
                            const stmtDetalles = db.prepare(`
                                INSERT INTO detalles_orden (
                                    orden_id, 
                                    producto_id, 
                                    cantidad, 
                                    precio_unitario,
                                    notas,
                                    creado_por
                                ) VALUES (?, ?, ?, ?, ?, ?)
                            `);

                            const stmtStock = db.prepare(`
                                UPDATE productos 
                                SET stock = stock - ?, 
                                    actualizado_por = ?,
                                    fecha_actualizacion = CURRENT_TIMESTAMP
                                WHERE id = ?
                            `);
                            
                            productos.forEach(prod => {
                                const precio = productosMap.get(prod.producto_id)?.precio || 0;
                                
                                // Insertar detalle de orden
                                stmtDetalles.run([
                                    orden_id, 
                                    prod.producto_id, 
                                    prod.cantidad, 
                                    precio,
                                    prod.notas || '',
                                    usuario_id
                                ]);

                                // Actualizar stock
                                stmtStock.run([
                                    prod.cantidad,
                                    usuario_id,
                                    prod.producto_id
                                ]);
                            });
                            
                            stmtDetalles.finalize();
                            stmtStock.finalize();
                            
                            // 4. Actualizar estado de la mesa
                            db.run(
                                'UPDATE mesas SET estado = "ocupada" WHERE id = ?',
                                [mesa_id],
                                function(err) {
                                    if (err) {
                                        console.error('Error al actualizar mesa:', err);
                                        db.run('ROLLBACK');
                                        return res.status(500).json({ error: 'Error al actualizar estado de mesa' });
                                    }

                                    db.run('COMMIT');
                                    res.json({ 
                                        message: 'Orden creada exitosamente',
                                        orden_id 
                                    });
                                }
                            );
                        }
                    );
                }
            );
        } catch (err) {
            console.error('Error en transacción:', err);
            db.run('ROLLBACK');
            res.status(500).json({ error: 'Error al procesar la orden' });
        }
    });
});

// Cancelar orden
router.post('/:id/cancelar', (req, res) => {
    const { id } = req.params;
    const usuario_id = req.user?.id;

    if (!usuario_id) {
        return res.status(401).json({ error: 'Usuario no autenticado' });
    }

    db.serialize(() => {
        db.run('BEGIN TRANSACTION');

        try {
            // 1. Obtener la orden y sus detalles
            db.all(
                `SELECT d.producto_id, d.cantidad, m.id as mesa_id
                FROM ordenes o
                JOIN detalles_orden d ON o.id = d.orden_id
                JOIN mesas m ON o.mesa_id = m.id
                WHERE o.id = ? AND o.estado = "activa"`,
                [id],
                function(err, detalles) {
                    if (err) {
                        console.error('Error al buscar orden:', err);
                        db.run('ROLLBACK');
                        return res.status(500).json({ error: 'Error al buscar la orden' });
                    }

                    if (!detalles || detalles.length === 0) {
                        db.run('ROLLBACK');
                        return res.status(404).json({ error: 'Orden no encontrada o no está activa' });
                    }

                    // 2. Actualizar estado de la orden
                    db.run(
                        `UPDATE ordenes 
                        SET estado = "cancelada",
                            actualizado_por = ?,
                            fecha_actualizacion = CURRENT_TIMESTAMP,
                            fecha_cierre = CURRENT_TIMESTAMP
                        WHERE id = ?`,
                        [usuario_id, id],
                        function(err) {
                            if (err) {
                                console.error('Error al cancelar orden:', err);
                                db.run('ROLLBACK');
                                return res.status(500).json({ error: 'Error al cancelar la orden' });
                            }

                            // 3. Restaurar stock
                            const stmtStock = db.prepare(`
                                UPDATE productos 
                                SET stock = stock + ?, 
                                    actualizado_por = ?,
                                    fecha_actualizacion = CURRENT_TIMESTAMP
                                WHERE id = ?
                            `);

                            detalles.forEach(detalle => {
                                stmtStock.run([
                                    detalle.cantidad,
                                    usuario_id,
                                    detalle.producto_id
                                ]);
                            });

                            stmtStock.finalize();

                            // 4. Actualizar estado de la mesa
                            db.run(
                                'UPDATE mesas SET estado = "disponible" WHERE id = ?',
                                [detalles[0].mesa_id],
                                function(err) {
                                    if (err) {
                                        console.error('Error al actualizar mesa:', err);
                                        db.run('ROLLBACK');
                                        return res.status(500).json({ error: 'Error al actualizar estado de mesa' });
                                    }

                                    db.run('COMMIT');
                                    res.json({ 
                                        message: 'Orden cancelada exitosamente',
                                        orden_id: id
                                    });
                                }
                            );
                        }
                    );
                }
            );
        } catch (err) {
            console.error('Error en transacción:', err);
            db.run('ROLLBACK');
            res.status(500).json({ error: 'Error al procesar la cancelación' });
        }
    });
});

// Cerrar orden con pago
router.post('/:id/pagar', (req, res) => {
    const { id } = req.params;
    const { metodo_pago, notas, pagos_divididos } = req.body;
    const usuario_id = req.user?.id;

    if (!usuario_id) {
        return res.status(401).json({ error: 'Usuario no autenticado' });
    }

    if (!metodo_pago || !['efectivo', 'tarjeta', 'transferencia'].includes(metodo_pago)) {
        return res.status(400).json({ error: 'Método de pago inválido' });
    }

    // Validar pagos divididos si se proporcionan
    if (pagos_divididos && Array.isArray(pagos_divididos)) {
        // Obtener el total de la orden
        db.get('SELECT total FROM ordenes WHERE id = ?', [id], (err, orden) => {
            if (err) {
                return res.status(500).json({ error: 'Error al obtener el total de la orden' });
            }

            const total = orden.total;
            const sumaPagos = pagos_divididos.reduce((sum, pago) => sum + pago.monto, 0);

            // Validar que la suma de los pagos sea igual al total
            if (Math.abs(sumaPagos - total) > 0.01) { // Permitir diferencia de 1 centavo por redondeo
                return res.status(400).json({ 
                    error: 'La suma de los pagos divididos debe ser igual al total de la orden',
                    total: total,
                    suma_pagos: sumaPagos
                });
            }
        });
    }

    db.serialize(() => {
        db.run('BEGIN TRANSACTION');

        try {
            // 1. Verificar que la orden exista y esté activa
            db.get(
                'SELECT mesa_id, total FROM ordenes WHERE id = ? AND estado = "activa"',
                [id],
                function(err, orden) {
                    if (err) {
                        console.error('Error al buscar orden:', err);
                        db.run('ROLLBACK');
                        return res.status(500).json({ error: 'Error al buscar la orden' });
                    }

                    if (!orden) {
                        db.run('ROLLBACK');
                        return res.status(404).json({ error: 'Orden no encontrada o no está activa' });
                    }

                    // 2. Actualizar estado de la orden
                    db.run(
                        `UPDATE ordenes 
                        SET estado = "cerrada",
                            metodo_pago = ?,
                            notas = CASE 
                                WHEN notas IS NULL OR notas = '' THEN ?
                                ELSE notas || ' | ' || ?
                            END,
                            actualizado_por = ?,
                            fecha_actualizacion = CURRENT_TIMESTAMP,
                            fecha_cierre = CURRENT_TIMESTAMP
                        WHERE id = ?`,
                        [metodo_pago, notas || '', notas || '', usuario_id, id],
                        function(err) {
                            if (err) {
                                console.error('Error al cerrar orden:', err);
                                db.run('ROLLBACK');
                                return res.status(500).json({ error: 'Error al cerrar la orden' });
                            }

                            // 3. Registrar pagos divididos si existen
                            if (pagos_divididos && Array.isArray(pagos_divididos)) {
                                const stmt = db.prepare(
                                    'INSERT INTO pagos_divididos (orden_id, cliente_numero, monto) VALUES (?, ?, ?)'
                                );

                                pagos_divididos.forEach((pago, index) => {
                                    stmt.run([id, index + 1, pago.monto], function(err) {
                                        if (err) {
                                            console.error('Error al registrar pago dividido:', err);
                                            db.run('ROLLBACK');
                                            return res.status(500).json({ error: 'Error al registrar pagos divididos' });
                                        }
                                    });
                                });

                                stmt.finalize();
                            }

                            // 4. Actualizar estado de la mesa
                            db.run(
                                'UPDATE mesas SET estado = "disponible" WHERE id = ?',
                                [orden.mesa_id],
                                function(err) {
                                    if (err) {
                                        console.error('Error al actualizar mesa:', err);
                                        db.run('ROLLBACK');
                                        return res.status(500).json({ error: 'Error al actualizar estado de mesa' });
                                    }

                                    db.run('COMMIT');
                                    res.json({ 
                                        message: 'Orden cerrada exitosamente',
                                        orden_id: id
                                    });
                                }
                            );
                        }
                    );
                }
            );
        } catch (err) {
            console.error('Error en transacción:', err);
            db.run('ROLLBACK');
            res.status(500).json({ error: 'Error al procesar el pago' });
        }
    });
});

// Registrar pago individual
router.post('/:id/pagar-individual', (req, res) => {
    const { id } = req.params;
    const { cliente_numero, monto, metodo_pago } = req.body;
    const usuario_id = req.user?.id;

    if (!usuario_id) {
        return res.status(401).json({ error: 'Usuario no autenticado' });
    }

    if (!['efectivo', 'tarjeta', 'transferencia'].includes(metodo_pago)) {
        return res.status(400).json({ error: 'Método de pago inválido' });
    }

    db.serialize(() => {
        db.run('BEGIN TRANSACTION');

        try {
            // 1. Verificar que la orden exista y esté activa
            db.get(
                'SELECT o.total, COALESCE(SUM(p.monto), 0) as total_pagado FROM ordenes o LEFT JOIN pagos_divididos p ON o.id = p.orden_id AND p.pagado = 1 WHERE o.id = ? AND o.estado = "activa" GROUP BY o.id',
                [id],
                function(err, orden) {
                    if (err) {
                        console.error('Error al buscar orden:', err);
                        db.run('ROLLBACK');
                        return res.status(500).json({ error: 'Error al buscar la orden' });
                    }

                    if (!orden) {
                        db.run('ROLLBACK');
                        return res.status(404).json({ error: 'Orden no encontrada o no está activa' });
                    }

                    // Verificar que el monto más lo ya pagado no exceda el total
                    const nuevo_total_pagado = orden.total_pagado + monto;
                    if (nuevo_total_pagado > orden.total) {
                        db.run('ROLLBACK');
                        return res.status(400).json({ 
                            error: 'El monto excede el saldo pendiente',
                            saldo_pendiente: orden.total - orden.total_pagado
                        });
                    }

                    // 2. Registrar el pago individual
                    db.run(
                        `INSERT INTO pagos_divididos (orden_id, cliente_numero, monto, metodo_pago, pagado, fecha_pago)
                         VALUES (?, ?, ?, ?, 1, CURRENT_TIMESTAMP)`,
                        [id, cliente_numero, monto, metodo_pago],
                        function(err) {
                            if (err) {
                                console.error('Error al registrar pago:', err);
                                db.run('ROLLBACK');
                                return res.status(500).json({ error: 'Error al registrar el pago' });
                            }

                            // 3. Verificar si ya se pagó el total y actualizar estado de la orden
                            if (Math.abs(nuevo_total_pagado - orden.total) < 0.01) {
                                db.run(
                                    `UPDATE ordenes 
                                     SET estado = "cerrada",
                                         fecha_actualizacion = CURRENT_TIMESTAMP,
                                         fecha_cierre = CURRENT_TIMESTAMP
                                     WHERE id = ?`,
                                    [id],
                                    function(err) {
                                        if (err) {
                                            console.error('Error al cerrar orden:', err);
                                            db.run('ROLLBACK');
                                            return res.status(500).json({ error: 'Error al actualizar estado de orden' });
                                        }

                                        // 4. Si la orden se cerró, actualizar estado de la mesa
                                        db.run(
                                            'UPDATE mesas SET estado = "disponible" WHERE id = (SELECT mesa_id FROM ordenes WHERE id = ?)',
                                            [id],
                                            function(err) {
                                                if (err) {
                                                    console.error('Error al actualizar mesa:', err);
                                                    db.run('ROLLBACK');
                                                    return res.status(500).json({ error: 'Error al actualizar estado de mesa' });
                                                }

                                                db.run('COMMIT');
                                                res.json({
                                                    message: 'Pago registrado exitosamente',
                                                    orden_cerrada: true
                                                });
                                            }
                                        );
                                    }
                                );
                            } else {
                                db.run('COMMIT');
                                res.json({
                                    message: 'Pago registrado exitosamente',
                                    orden_cerrada: false,
                                    saldo_pendiente: orden.total - nuevo_total_pagado
                                });
                            }
                        }
                    );
                }
            );
        } catch (err) {
            console.error('Error en transacción:', err);
            db.run('ROLLBACK');
            res.status(500).json({ error: 'Error al procesar el pago' });
        }
    });
});

// Obtener resumen de pagos de una orden
router.get('/:id/pagos', (req, res) => {
    const { id } = req.params;
    
    const query = `
        SELECT 
            p.cliente_numero,
            p.monto,
            p.metodo_pago,
            p.pagado,
            datetime(p.fecha_pago, 'localtime') as fecha_pago,
            o.total as total_orden,
            (SELECT COALESCE(SUM(monto), 0) FROM pagos_divididos WHERE orden_id = o.id AND pagado = 1) as total_pagado
        FROM pagos_divididos p
        JOIN ordenes o ON p.orden_id = o.id
        WHERE p.orden_id = ?
        ORDER BY p.cliente_numero
    `;

    db.all(query, [id], (err, pagos) => {
        if (err) {
            console.error('Error al obtener pagos:', err);
            return res.status(500).json({ error: 'Error al obtener resumen de pagos' });
        }

        res.json({
            pagos,
            total_orden: pagos[0]?.total_orden || 0,
            total_pagado: pagos[0]?.total_pagado || 0
        });
    });
});

module.exports = router;