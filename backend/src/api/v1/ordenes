const express = require('express');
const router = express.Router();
const db = require('../../../config/database');

// Obtener órdenes con filtros
router.get('/', (req, res) => {
    const { estado, fecha_inicio, fecha_fin } = req.query;
    
    let query = `
        SELECT 
            o.id,
            o.total,
            o.estado,
            o.fecha_creacion as hora,
            o.fecha_cierre,
            o.metodo_pago,
            json_object('numero', m.numero) as mesa,
            u.nombre as mesero,
            COUNT(d.id) as productos
        FROM ordenes o
        LEFT JOIN mesas m ON o.mesa_id = m.id
        LEFT JOIN usuarios u ON o.usuario_id = u.id
        LEFT JOIN detalles_orden d ON o.id = d.orden_id
        WHERE 1=1
    `;
    
    const params = [];
    
    if (estado) {
        query += ' AND o.estado = ?';
        params.push(estado);
    }
    
    if (fecha_inicio) {
        query += ' AND DATE(o.fecha_creacion) >= DATE(?)';
        params.push(fecha_inicio);
    }
    
    if (fecha_fin) {
        query += ' AND DATE(o.fecha_creacion) <= DATE(?)';
        params.push(fecha_fin);
    }
    
    query += ' GROUP BY o.id ORDER BY o.fecha_creacion DESC';

    db.all(query, params, (err, rows) => {
        if (err) {
            console.error('Error en la consulta:', err);
            res.status(500).json({ error: err.message });
            return;
        }

        const formattedRows = rows.map(row => ({
            ...row,
            hora: new Date(row.hora).toLocaleTimeString(),
            fecha_cierre: row.fecha_cierre ? new Date(row.fecha_cierre).toLocaleTimeString() : null,
            total: parseFloat(row.total).toFixed(2),
            mesa: JSON.parse(row.mesa)
        }));

        res.json(formattedRows);
    });
});

// Get active orders
router.get('/activas', (req, res) => {
    const query = `
        SELECT 
            o.id,
            o.total,
            o.estado,
            o.fecha_creacion as hora,
            m.numero as mesa,
            u.nombre as mesero,
            COUNT(d.id) as productos
        FROM ordenes o
        JOIN mesas m ON o.mesa_id = m.id
        JOIN usuarios u ON o.usuario_id = u.id
        LEFT JOIN detalles_orden d ON o.id = d.orden_id
        WHERE o.estado = 'activa'
        GROUP BY o.id
        ORDER BY o.fecha_creacion DESC
    `;

    db.all(query, [], (err, rows) => {
        if (err) {
            console.error('Error getting active orders:', err);
            return res.status(500).json({ error: err.message });
        }

        const formattedRows = rows.map(row => ({
            ...row,
            hora: new Date(row.hora).toISOString(),
            total: parseFloat(row.total).toFixed(2)
        }));

        res.json(formattedRows);
    });
});

// Añadir ruta para obtener detalles de una orden específica
router.get('/:id', (req, res) => {
    const { id } = req.params;
    
    const query = `
        SELECT 
            o.*,
            m.numero as mesa_numero,
            u.nombre as mesero_nombre,
            json_group_array(
                json_object(
                    'id', p.id,
                    'nombre', p.nombre,
                    'precio', d.precio_unitario,
                    'cantidad', d.cantidad
                )
            ) as productos
        FROM ordenes o
        LEFT JOIN mesas m ON o.mesa_id = m.id
        LEFT JOIN usuarios u ON o.usuario_id = u.id
        LEFT JOIN detalles_orden d ON o.id = d.orden_id
        LEFT JOIN productos p ON d.producto_id = p.id
        WHERE o.id = ?
        GROUP BY o.id
    `;

    db.get(query, [id], (err, orden) => {
        if (err) {
            res.status(500).json({ error: err.message });
            return;
        }

        if (!orden) {
            res.status(404).json({ error: 'Orden no encontrada' });
            return;
        }

        // Parsear el array de productos que viene como string
        orden.productos = JSON.parse(orden.productos);
        
        res.json(orden);
    });
});

// Crear nueva orden
router.post('/', (req, res) => {
    const { mesa_id, mesero_id, productos, num_personas, notas } = req.body;
    
    if (!mesa_id || !mesero_id || !productos || !productos.length) {
        return res.status(400).json({ 
            error: 'Faltan datos requeridos (mesa_id, mesero_id, productos)' 
        });
    }
    
    db.serialize(() => {
        // 1. Iniciar transacción
        db.run('BEGIN TRANSACTION');
        
        try {
            // Verificar stock de productos
            const stockQuery = `
                SELECT id, nombre, stock, stock_minimo
                FROM productos 
                WHERE id IN (${productos.map(() => '?').join(',')})
            `;
            
            db.all(stockQuery, productos.map(p => p.producto_id), (err, productosInfo) => {
                if (err) {
                    console.error('Error al verificar stock:', err);
                    db.run('ROLLBACK');
                    return res.status(500).json({ error: 'Error al verificar stock de productos' });
                }

                // Crear mapa de productos solicitados para fácil acceso
                const productosMap = new Map(productos.map(p => [p.producto_id, p.cantidad]));
                
                // Verificar stock suficiente
                const stockInsuficiente = productosInfo.find(p => 
                    (p.stock - (productosMap.get(p.id) || 0)) < 0
                );

                if (stockInsuficiente) {
                    db.run('ROLLBACK');
                    return res.status(400).json({ 
                        error: `Stock insuficiente para: ${stockInsuficiente.nombre}`
                    });
                }

                // 2. Crear la orden
                db.run(
                    'INSERT INTO ordenes (mesa_id, usuario_id, estado, total, num_personas, notas) VALUES (?, ?, "activa", 0, ?, ?)',
                    [mesa_id, mesero_id, num_personas || 1, notas || ''],
                    function(err) {
                        if (err) {
                            console.error('Error al crear orden:', err);
                            db.run('ROLLBACK');
                            return res.status(500).json({ error: err.message });
                        }
                        
                        const orden_id = this.lastID;
                        
                        try {
                            // 3. Insertar los productos y actualizar stock
                            const stmtDetalles = db.prepare(`
                                INSERT INTO detalles_orden (
                                    orden_id, producto_id, cantidad, precio_unitario
                                ) VALUES (?, ?, ?, (
                                    SELECT precio FROM productos WHERE id = ?
                                ))
                            `);
                            
                            const stmtStock = db.prepare(`
                                UPDATE productos 
                                SET stock = stock - ?,
                                    fecha_actualizacion = CURRENT_TIMESTAMP
                                WHERE id = ?
                            `);
                            
                            const stmtMovimiento = db.prepare(`
                                INSERT INTO movimientos_inventario (
                                    producto_id, tipo, cantidad, motivo, 
                                    orden_id, usuario_id
                                ) VALUES (?, 'salida', ?, 'Venta en orden', ?, ?)
                            `);
                            
                            productos.forEach(prod => {
                                stmtDetalles.run([orden_id, prod.producto_id, prod.cantidad, prod.producto_id]);
                                stmtStock.run([prod.cantidad, prod.producto_id]);
                                stmtMovimiento.run([prod.producto_id, prod.cantidad, orden_id, mesero_id]);
                            });
                            
                            stmtDetalles.finalize();
                            stmtStock.finalize();
                            stmtMovimiento.finalize();
                            
                            // 4. Actualizar el total de la orden
                            db.run(`
                                UPDATE ordenes 
                                SET total = (
                                    SELECT SUM(cantidad * precio_unitario) 
                                    FROM detalles_orden 
                                    WHERE orden_id = ?
                                )
                                WHERE id = ?
                            `, [orden_id, orden_id]);
                            
                            // 5. Actualizar estado de la mesa
                            db.run(
                                'UPDATE mesas SET estado = "ocupada" WHERE id = ?',
                                [mesa_id]
                            );
                            
                            // 6. Confirmar transacción
                            db.run('COMMIT');
                            
                            res.json({ 
                                message: 'Orden creada exitosamente',
                                orden_id 
                            });
                        } catch (err) {
                            console.error('Error al procesar productos:', err);
                            db.run('ROLLBACK');
                            res.status(500).json({ error: err.message });
                        }
                    }
                );
            });
        } catch (err) {
            console.error('Error en la transacción:', err);
            db.run('ROLLBACK');
            res.status(500).json({ error: err.message });
        }
    });
});

// Procesar pago de orden
router.post('/:id/pagar', (req, res) => {
    const { id } = req.params;
    const { metodo_pago, notas, pagos_divididos } = req.body;

    if (!metodo_pago) {
        return res.status(400).json({ error: 'El método de pago es requerido' });
    }

    db.serialize(() => {
        db.run('BEGIN TRANSACTION');

        try {
            // Verificar que la orden exista y esté activa
            db.get(
                'SELECT estado, total FROM ordenes WHERE id = ?',
                [id],
                (err, orden) => {
                    if (err) {
                        db.run('ROLLBACK');
                        return res.status(500).json({ error: err.message });
                    }

                    if (!orden) {
                        db.run('ROLLBACK');
                        return res.status(404).json({ error: 'Orden no encontrada' });
                    }

                    if (orden.estado !== 'activa') {
                        db.run('ROLLBACK');
                        return res.status(400).json({ 
                            error: 'No se puede procesar el pago. La orden no está activa' 
                        });
                    }

                    // Si hay pagos divididos, validar que la suma sea igual al total
                    if (pagos_divididos && pagos_divididos.length > 0) {
                        const totalPagos = pagos_divididos.reduce((sum, pago) => sum + pago.monto, 0);
                        if (Math.abs(totalPagos - orden.total) > 0.01) {
                            db.run('ROLLBACK');
                            return res.status(400).json({ 
                                error: 'La suma de los pagos divididos debe ser igual al total de la orden' 
                            });
                        }
                    }

                    // Procesar el pago
                    db.run(
                        'UPDATE ordenes SET estado = "cerrada", metodo_pago = ?, notas = ?, fecha_cierre = CURRENT_TIMESTAMP WHERE id = ?',
                        [metodo_pago, notas || null, id],
                        function(err) {
                            if (err) {
                                db.run('ROLLBACK');
                                return res.status(500).json({ error: err.message });
                            }

                            // Liberar la mesa ya que la orden está pagada
                            db.run(
                                `UPDATE mesas 
                                SET estado = "disponible" 
                                WHERE id = (SELECT mesa_id FROM ordenes WHERE id = ?)`,
                                [id],
                                function(err) {
                                    if (err) {
                                        db.run('ROLLBACK');
                                        return res.status(500).json({ error: err.message });
                                    }

                                    // Si hay pagos divididos, registrarlos
                                    if (pagos_divididos && pagos_divididos.length > 0) {
                                        const stmt = db.prepare(
                                            'INSERT INTO pagos_divididos (orden_id, cliente_numero, monto, metodo_pago) VALUES (?, ?, ?, ?)'
                                        );

                                        try {
                                            pagos_divididos.forEach(pago => {
                                                stmt.run([id, pago.cliente_numero, pago.monto, pago.metodo_pago || metodo_pago]);
                                            });
                                            stmt.finalize();
                                        } catch (err) {
                                            db.run('ROLLBACK');
                                            return res.status(500).json({ error: 'Error al registrar pagos divididos' });
                                        }
                                    }

                                    db.run('COMMIT');
                                    res.json({ message: 'Orden pagada exitosamente' });
                                }
                            );
                        }
                    );
                }
            );
        } catch (err) {
            db.run('ROLLBACK');
            res.status(500).json({ error: err.message });
        }
    });
});

module.exports = router;